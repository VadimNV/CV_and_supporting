Vadim Nemytov (vadim.nemytov13@imperial.ac.uk)

3 different data structures to implement associative arrays where both keys and values are strings:

1. Hash Table. 
  - About: In a Hash Table data structure, a hash function is used. This type of function is able to map input 
           string object to an associated hash. Hash in turn is a primitive type, often an int or a long and it can 
           be used directly as an index pointing to a location in an array. This array stores a reference/pointer
           indicating where the (key,value) pair is stored in memory. Hash function is *almost* injective and so for
           a given unique input string it maps to (almost) a unique hash/index. Later, when a string key is passed
           on as input to, say, retrieve a value, the hash function converts it to a (almost) unique index which 
           then points in memory to the cell that stores the values.
  - Pros:  It is fast. Search, Insert and Delete are performed on average with speed O(1) and at worst linear in
           the number of pairs.
  - Cons:  The algorithm behind the hash function makes it improbable to map two distinct inputs to the same index,
           however it may occur (called collision). When this occurs security and/or integrity of the system is compromised.
           E.g. read about SHA-1 or MD5 [1].

2. Search Tree
  - About: Search tree would order strings alphabetically, to define an ordered set, e.g. a<b, c==c, d>c, car < cat. The
           key-string does not quite give a location in the memory, but does tell where it is NOT located; indicating if 
           you are "close" or "far" from the location. The search tree is built and rebalanced on the fly as the data-base
           is being built up. After a few (key,value) pairs have been save, with keys say "apple", "aqua", "pear", "grape",
           "car", "Oxford", "book", the tree (say, Binary Search Tree) might look like this (showing keys):
                            g           (==? :  grape)
                           / \_________________
            (==? : book)  b                    O  (==? Oxford)
                         / \                    \
         (==? : apple)  ap   c  (==? car)        p  (==? pear)
                       /
        (==? : aqua)  aq
           Here, for a given input, you keep asking if the input-string is greater or less than the given node. If it's
           neither greater nor less (i.e. equal) - you are done searching. I indicated only the necessary letters - usually
           the first, or first two for words "apple" and "aqua".
  - Pros:  You should not have any collisions.
  - Cons:  Search, Insert, Delete are O(log N) - this is slower than using a Hash Table.
           
3. custom made class.
  - About: Well, one can write one's one class. The quickest and easiest class to write is the one that simply keeps
           adding string keys and values to two arrays of strings. When one then wants to retrive the value associated
           with a key, the getter function of the class simply goes through each item and checks string equality 
           'input'=='key in array' in a primitive way, for every element of the array. One could do a bit better by 
           grouping keys into different array based on number of characters.
  - Pros: It's very easy, quick and intuitive to implement and test. There are no collisions. Although this method does
          not scale well, it likely has smaller prefactor than Search Tree or Hash Table methods. As such, for applications
          where we know the (key,value) array will be short (e.g. few tens of pairs) this may end up being the fastest method.
  - Cons: It does not scale well. Average Search/Delete/Replace time is O(N).

(Source: Google, Wiki, stackoverflow)
[1] https://arstechnica.co.uk/information-technology/2017/02/at-deaths-door-for-years-widely-used-sha1-function-is-now-dead/
